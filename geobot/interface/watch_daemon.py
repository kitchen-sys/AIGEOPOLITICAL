"""
Watch Mode Daemon for GeoBotv1

Autonomous monitoring system that:
- Monitors intelligence feeds continuously
- Updates models with new data
- Generates alerts when significant changes detected
- Runs in background with minimal human intervention
- Allows chat override for manual queries

Alerts are triggered by:
- Regime shifts (HMM state changes)
- Risk threshold breaches (Hawkes branching ratio)
- Anomalies (Kalman innovation spikes)
- Structural breaks (VAR coefficient changes)
"""

from enum import Enum
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Callable
from datetime import datetime, timedelta
import time
from threading import Thread, Event


class AlertLevel(Enum):
    """Alert severity levels."""
    INFO = "info"          # Informational
    LOW = "low"           # Minor concern
    MEDIUM = "medium"     # Moderate concern
    HIGH = "high"         # Significant concern
    CRITICAL = "critical"  # Immediate attention required


class AlertType(Enum):
    """Types of alerts."""
    REGIME_SHIFT = "regime_shift"  # HMM state change
    RISK_THRESHOLD = "risk_threshold"  # Risk exceeded threshold
    ANOMALY = "anomaly"  # Unusual observation
    CONTAGION = "contagion"  # Conflict spread detected
    STRUCTURAL_BREAK = "structural_break"  # Model parameters changed
    DATA_GAP = "data_gap"  # Missing expected data
    MODEL_DEGRADATION = "model_degradation"  # Model performance declined


@dataclass
class Alert:
    """Alert generated by watch daemon."""
    alert_id: str
    timestamp: datetime
    level: AlertLevel
    alert_type: AlertType
    title: str
    message: str
    entities: List[str] = field(default_factory=list)
    data: Dict = field(default_factory=dict)
    actions_recommended: List[str] = field(default_factory=list)
    auto_resolved: bool = False


class WatchDaemon:
    """
    Autonomous monitoring daemon for continuous intelligence analysis.

    Example:
        >>> daemon = WatchDaemon(check_interval=300)  # Check every 5 minutes
        >>>
        >>> # Configure alert thresholds
        >>> daemon.set_threshold('risk_score', 0.7, AlertLevel.MEDIUM)
        >>> daemon.set_threshold('branching_ratio', 0.9, AlertLevel.HIGH)
        >>>
        >>> # Register alert handler
        >>> def handle_alert(alert):
        ...     print(f"ALERT: {alert.title}")
        ...     send_email(alert)
        >>> daemon.register_alert_handler(handle_alert)
        >>>
        >>> # Start monitoring
        >>> daemon.start()
        >>>
        >>> # Chat override while monitoring
        >>> daemon.ask("What changed in the last 24 hours?")
        >>>
        >>> # Stop monitoring
        >>> daemon.stop()
    """

    def __init__(
        self,
        check_interval: int = 300,  # seconds
        alert_threshold: AlertLevel = AlertLevel.MEDIUM,
        auto_update_models: bool = True
    ):
        """
        Initialize watch daemon.

        Args:
            check_interval: Seconds between checks
            alert_threshold: Minimum level to notify
            auto_update_models: Automatically retrain models with new data
        """
        self.check_interval = check_interval
        self.alert_threshold = alert_threshold
        self.auto_update_models = auto_update_models

        self.is_running = False
        self.stop_event = Event()
        self.monitor_thread: Optional[Thread] = None

        self.alert_history: List[Alert] = []
        self.alert_handlers: List[Callable[[Alert], None]] = []

        self.thresholds: Dict[str, Tuple[float, AlertLevel]] = {
            'risk_score': (0.75, AlertLevel.MEDIUM),
            'branching_ratio': (0.85, AlertLevel.HIGH),
            'anomaly_score': (3.0, AlertLevel.MEDIUM),  # Standard deviations
        }

        self.last_check: Optional[datetime] = None
        self.checks_completed: int = 0
        self.alerts_generated: int = 0

        # State tracking
        self.previous_state: Dict[str, Any] = {}
        self.current_state: Dict[str, Any] = {}

    def start(self) -> None:
        """Start autonomous monitoring."""
        if self.is_running:
            print("âš ï¸ Watch daemon already running")
            return

        self.is_running = True
        self.stop_event.clear()

        # Start monitoring thread
        self.monitor_thread = Thread(target=self._monitor_loop, daemon=True)
        self.monitor_thread.start()

        print(f"ðŸ” Watch daemon started (check interval: {self.check_interval}s)")
        print(f"   Alert threshold: {self.alert_threshold.value}")
        print(f"   Auto-update models: {self.auto_update_models}")

    def stop(self) -> None:
        """Stop autonomous monitoring."""
        if not self.is_running:
            return

        print("\nâ¸ï¸  Stopping watch daemon...")
        self.is_running = False
        self.stop_event.set()

        if self.monitor_thread:
            self.monitor_thread.join(timeout=10)

        print(f"âœ“ Watch daemon stopped")
        print(f"  Total checks: {self.checks_completed}")
        print(f"  Alerts generated: {self.alerts_generated}")

    def _monitor_loop(self) -> None:
        """Main monitoring loop (runs in background thread)."""
        while not self.stop_event.is_set():
            try:
                # Perform check
                self._perform_check()

                # Wait for next check
                self.stop_event.wait(self.check_interval)

            except Exception as e:
                print(f"âŒ Error in monitoring loop: {e}")
                self.stop_event.wait(60)  # Wait 1 minute before retrying

    def _perform_check(self) -> None:
        """Perform a single monitoring check."""
        check_start = datetime.utcnow()
        self.checks_completed += 1

        # Update state
        self.previous_state = self.current_state.copy()
        self.current_state = self._gather_current_state()

        # Check for alerts
        alerts = self._detect_alerts()

        # Filter by threshold
        filtered_alerts = [
            a for a in alerts
            if self._alert_level_value(a.level) >= self._alert_level_value(self.alert_threshold)
        ]

        # Notify handlers
        for alert in filtered_alerts:
            self._notify_alert(alert)

        self.last_check = check_start

        # Print status
        if filtered_alerts:
            print(f"\n[{check_start.strftime('%H:%M:%S')}] Check #{self.checks_completed}: {len(filtered_alerts)} alert(s)")
        else:
            print(f"[{check_start.strftime('%H:%M:%S')}] Check #{self.checks_completed}: No alerts")

    def _gather_current_state(self) -> Dict[str, Any]:
        """
        Gather current state from all models and data sources.

        In production, this:
        - Fetches latest intelligence data
        - Runs all models
        - Computes risk scores
        - Detects anomalies

        For now, returns simulated state.
        """
        import random

        state = {
            'timestamp': datetime.utcnow(),
            'risk_score': random.uniform(0.3, 0.9),
            'branching_ratio': random.uniform(0.4, 0.95),
            'regime_state': random.choice(['stable', 'transitioning', 'unstable']),
            'anomaly_score': random.uniform(0, 4),
            'new_events_count': random.randint(0, 15),
            'model_performance': {
                'var_mse': random.uniform(0.02, 0.08),
                'hawkes_aic': random.uniform(100, 150)
            }
        }

        return state

    def _detect_alerts(self) -> List[Alert]:
        """Detect alerts based on current vs previous state."""
        alerts = []

        # Check risk threshold
        if self.current_state['risk_score'] > self.thresholds['risk_score'][0]:
            alerts.append(Alert(
                alert_id=self._generate_alert_id(),
                timestamp=datetime.utcnow(),
                level=self.thresholds['risk_score'][1],
                alert_type=AlertType.RISK_THRESHOLD,
                title="Risk Threshold Exceeded",
                message=f"Current risk score ({self.current_state['risk_score']:.2f}) exceeds threshold ({self.thresholds['risk_score'][0]:.2f})",
                data={'risk_score': self.current_state['risk_score']},
                actions_recommended=["Review recent intelligence", "Run detailed forecast"]
            ))

        # Check branching ratio
        if self.current_state['branching_ratio'] > self.thresholds['branching_ratio'][0]:
            alerts.append(Alert(
                alert_id=self._generate_alert_id(),
                timestamp=datetime.utcnow(),
                level=self.thresholds['branching_ratio'][1],
                alert_type=AlertType.CONTAGION,
                title="Conflict Contagion Risk Elevated",
                message=f"Hawkes branching ratio ({self.current_state['branching_ratio']:.2f}) approaching supercritical threshold",
                data={'branching_ratio': self.current_state['branching_ratio']},
                actions_recommended=["Monitor closely", "Assess contagion pathways"]
            ))

        # Check regime shift
        if self.previous_state and self.previous_state.get('regime_state') != self.current_state['regime_state']:
            old_regime = self.previous_state.get('regime_state', 'unknown')
            new_regime = self.current_state['regime_state']

            level = AlertLevel.HIGH if new_regime == 'unstable' else AlertLevel.MEDIUM

            alerts.append(Alert(
                alert_id=self._generate_alert_id(),
                timestamp=datetime.utcnow(),
                level=level,
                alert_type=AlertType.REGIME_SHIFT,
                title="Regime State Change Detected",
                message=f"Regime shifted from '{old_regime}' to '{new_regime}'",
                data={'old_regime': old_regime, 'new_regime': new_regime},
                actions_recommended=["Investigate triggers", "Update forecasts"]
            ))

        # Check anomalies
        if self.current_state['anomaly_score'] > self.thresholds['anomaly_score'][0]:
            alerts.append(Alert(
                alert_id=self._generate_alert_id(),
                timestamp=datetime.utcnow(),
                level=self.thresholds['anomaly_score'][1],
                alert_type=AlertType.ANOMALY,
                title="Anomalous Observation Detected",
                message=f"Anomaly score ({self.current_state['anomaly_score']:.1f}Ïƒ) indicates unusual pattern",
                data={'anomaly_score': self.current_state['anomaly_score']},
                actions_recommended=["Verify data quality", "Investigate cause"]
            ))

        return alerts

    def _notify_alert(self, alert: Alert) -> None:
        """Notify all registered handlers about an alert."""
        self.alert_history.append(alert)
        self.alerts_generated += 1

        # Console output
        level_emoji = {
            AlertLevel.INFO: "â„¹ï¸ ",
            AlertLevel.LOW: "ðŸ”µ",
            AlertLevel.MEDIUM: "ðŸŸ¡",
            AlertLevel.HIGH: "ðŸŸ ",
            AlertLevel.CRITICAL: "ðŸ”´"
        }

        print(f"\n{level_emoji.get(alert.level, 'âš ï¸')} ALERT [{alert.level.value.upper()}]: {alert.title}")
        print(f"   {alert.message}")
        if alert.actions_recommended:
            print(f"   Recommended actions:")
            for action in alert.actions_recommended:
                print(f"     â€¢ {action}")

        # Call registered handlers
        for handler in self.alert_handlers:
            try:
                handler(alert)
            except Exception as e:
                print(f"   Error in alert handler: {e}")

    def register_alert_handler(self, handler: Callable[[Alert], None]) -> None:
        """
        Register a function to be called when alerts are generated.

        Args:
            handler: Function that takes an Alert object
        """
        self.alert_handlers.append(handler)

    def set_threshold(self, metric: str, value: float, level: AlertLevel) -> None:
        """
        Set alert threshold for a metric.

        Args:
            metric: Metric name (e.g., 'risk_score', 'branching_ratio')
            value: Threshold value
            level: Alert level when exceeded
        """
        self.thresholds[metric] = (value, level)
        print(f"âœ“ Set {metric} threshold: {value} (level: {level.value})")

    def ask(self, question: str) -> str:
        """
        Chat override: Ask a question while daemon is running.

        Args:
            question: Natural language question

        Returns:
            Answer string
        """
        from .analyst_agent import AnalystAgent

        # Temporary pause monitoring
        was_running = self.is_running

        # Use analyst agent
        agent = AnalystAgent()
        result = agent.analyze(question)

        return result.narrative_answer

    def get_recent_alerts(self, hours: int = 24, min_level: Optional[AlertLevel] = None) -> List[Alert]:
        """
        Get recent alerts.

        Args:
            hours: How many hours back to look
            min_level: Minimum alert level

        Returns:
            List of alerts
        """
        cutoff = datetime.utcnow() - timedelta(hours=hours)
        alerts = [a for a in self.alert_history if a.timestamp >= cutoff]

        if min_level:
            min_value = self._alert_level_value(min_level)
            alerts = [a for a in alerts if self._alert_level_value(a.level) >= min_value]

        return sorted(alerts, key=lambda a: a.timestamp, reverse=True)

    def get_status(self) -> Dict[str, Any]:
        """Get current daemon status."""
        return {
            'is_running': self.is_running,
            'check_interval': self.check_interval,
            'last_check': self.last_check.isoformat() if self.last_check else None,
            'checks_completed': self.checks_completed,
            'alerts_generated': self.alerts_generated,
            'alert_threshold': self.alert_threshold.value,
            'auto_update_models': self.auto_update_models,
            'thresholds': {k: v[0] for k, v in self.thresholds.items()},
            'current_state': self.current_state
        }

    def print_status(self) -> None:
        """Print daemon status to console."""
        print("\n" + "="*70)
        print("Watch Daemon Status")
        print("="*70)
        print(f"\nðŸ” State: {'RUNNING' if self.is_running else 'STOPPED'}")

        if self.last_check:
            print(f"â±ï¸  Last check: {self.last_check.strftime('%Y-%m-%d %H:%M:%S')}")

        print(f"ðŸ“Š Checks completed: {self.checks_completed}")
        print(f"ðŸš¨ Alerts generated: {self.alerts_generated}")

        print(f"\nâš™ï¸  Configuration:")
        print(f"   Check interval: {self.check_interval}s")
        print(f"   Alert threshold: {self.alert_threshold.value}")
        print(f"   Auto-update models: {self.auto_update_models}")

        print(f"\nðŸ“ Thresholds:")
        for metric, (value, level) in self.thresholds.items():
            print(f"   {metric}: {value} (level: {level.value})")

        if self.current_state:
            print(f"\nðŸ“ˆ Current State:")
            for key, value in self.current_state.items():
                if key != 'timestamp':
                    print(f"   {key}: {value}")

        recent_alerts = self.get_recent_alerts(hours=24)
        if recent_alerts:
            print(f"\nðŸš¨ Recent Alerts (last 24h): {len(recent_alerts)}")
            for alert in recent_alerts[:5]:
                print(f"   [{alert.timestamp.strftime('%H:%M:%S')}] {alert.title} ({alert.level.value})")

        print("\n" + "="*70)

    def _generate_alert_id(self) -> str:
        """Generate unique alert ID."""
        import uuid
        return f"alert_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{str(uuid.uuid4())[:8]}"

    def _alert_level_value(self, level: AlertLevel) -> int:
        """Convert alert level to numeric value for comparison."""
        values = {
            AlertLevel.INFO: 0,
            AlertLevel.LOW: 1,
            AlertLevel.MEDIUM: 2,
            AlertLevel.HIGH: 3,
            AlertLevel.CRITICAL: 4
        }
        return values.get(level, 0)
